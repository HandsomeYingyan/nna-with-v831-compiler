/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __fastcall nna_net_dump_quant(_DWORD *a1);
int __fastcall nna_net_dump_data(_DWORD *a1);
int __fastcall nna_net_dump_layer(_DWORD *a1);
int __fastcall nna_net_dump_info(int a1);
int __fastcall nna_save_ram(int a1, int a2, const char *a3);
int __fastcall nna_load_ram(int a1, const char *a2, int a3);
int __fastcall nna_load_buf(void *a1, int a2, char *a3);
int __fastcall nna_save_buf(void *a1, int a2, char *a3);
int __fastcall nna_net_get_quant(int a1, int a2, int a3);
int __fastcall nna_net_load_quant(_DWORD *a1);
int __fastcall nna_net_load_data(int result);
int __fastcall nna_net_load_hyper(int result);
_DWORD *__fastcall nna_net_init_whc(_DWORD *result, int a2, int a3, int a4);
int __fastcall nna_net_init(int result, int a2, signed int a3, int a4);
int __fastcall nna_net_dump(_DWORD *a1);
int __fastcall nna_net_forward(int result);
// int printf(const char *format, ...);
// int putchar(int c);
// FILE *fopen(const char *filename, const char *modes);
// int __cdecl xfile(_DWORD, _DWORD, _DWORD); weak
// int fclose(FILE *stream);
// int fseek(FILE *stream, int off, int whence);
// int ftell(FILE *stream);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// _DWORD __cdecl nna_conv_get_output_w(int, int, int, int, int); idb
// _DWORD __cdecl nna_conv_get_output_h(int, int, int, int, int); idb
// _DWORD __cdecl nna_pool_get_output_w(int, int, int, int); idb
// _DWORD __cdecl nna_pool_get_output_h(int, int, int, int); idb
// int sprintf(char *s, const char *format, ...);
// int __fastcall nna_diff_file(_DWORD, _DWORD); weak
// int __fastcall nna_reset(_DWORD); weak
// int __fastcall xramset(_DWORD, _DWORD); weak
// int __fastcall nna_conv_act_pool(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl nna_api_conv_act(unsigned int, unsigned int, unsigned int, unsigned int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); idb
// _DWORD __cdecl nna_api_inner_product(unsigned int, unsigned int, unsigned int, unsigned int, int, int, int, int, int, int, int); idb
// _DWORD __cdecl nna_api_conv_act_eltwise(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); idb
// int __fastcall nna_eltwise_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall nna_sigmoid_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __fastcall nna_concat_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak

//-------------------------------------------------------------------------
// Data declarations

char *map_layer_type_name[9] =
{
  "NET_INPUT   ",
  "CN_BN_ACT_PL",
  "CN_BN_ACT   ",
  "CN_IP       ",
  "CN_BN_ACT_EW",
  "EW          ",
  "SG          ",
  "CONCAT      ",
  "NTE_OUTPUT  "
}; // weak
char *off_19E8[8] =
{
  "CN_BN_ACT_PL",
  "CN_BN_ACT   ",
  "CN_IP       ",
  "CN_BN_ACT_EW",
  "EW          ",
  "SG          ",
  "CONCAT      ",
  "NTE_OUTPUT  "
}; // weak
char *off_19EC[7] =
{
  "CN_BN_ACT   ",
  "CN_IP       ",
  "CN_BN_ACT_EW",
  "EW          ",
  "SG          ",
  "CONCAT      ",
  "NTE_OUTPUT  "
}; // weak
char *off_19F0[6] =
{
  "CN_IP       ",
  "CN_BN_ACT_EW",
  "EW          ",
  "SG          ",
  "CONCAT      ",
  "NTE_OUTPUT  "
}; // weak
char *off_19F4[5] =
{
  "CN_BN_ACT_EW",
  "EW          ",
  "SG          ",
  "CONCAT      ",
  "NTE_OUTPUT  "
}; // weak
char *off_19F8[4] = { "EW          ", "SG          ", "CONCAT      ", "NTE_OUTPUT  " }; // weak
char *off_19FC[3] = { "SG          ", "CONCAT      ", "NTE_OUTPUT  " }; // weak
char *off_1A00[2] = { "CONCAT      ", "NTE_OUTPUT  " }; // weak


//----- (00000004) --------------------------------------------------------
int __fastcall nna_net_dump_quant(_DWORD *a1)
{
  _DWORD *v1; // r4
  int *v2; // r5
  int v3; // r6
  int *v4; // r5
  int v5; // t1
  int v6; // t1
  char *v7; // r6
  int v8; // r5
  int v9; // t1

  v1 = a1;
  v2 = a1;
  v3 = (int)(a1 + 33);
  printf("\n NNA_QUANT_DATA ----");
  v5 = *v2;
  v4 = v2 + 1;
  printf("\n size \t  :%d", v5);
  printf("\n quant_map  :[");
  do
  {
    v6 = *v4;
    ++v4;
    printf("%d ", v6);
  }
  while ( v4 != (int *)v3 );
  v7 = (char *)(v1 + 129);
  putchar(93);
  v8 = 0;
  printf("\n quant_buf  :[");
  while ( v8 < *v1 )
  {
    v9 = *v7++;
    ++v8;
    printf("%d ", v9);
  }
  putchar(93);
  return printf("\n file \t  :%s ", v1 + 161);
}

//----- (000000E0) --------------------------------------------------------
int __fastcall nna_net_dump_data(_DWORD *a1)
{
  _DWORD *v1; // r4

  v1 = a1;
  printf("\n NNA_LAYER_DATA ----");
  printf("\n addr \t  :%x", *v1);
  printf("\n type \t  :%d", v1[1]);
  printf("\n size \t  :%d", v1[2]);
  printf("\n whcn \t  :[%d %d %d %d]", v1[3], v1[4], v1[5], v1[6]);
  return printf("\n file \t  :%s ", v1 + 7);
}

//----- (0000017C) --------------------------------------------------------
int __fastcall nna_net_dump_layer(_DWORD *a1)
{
  _DWORD *v1; // r4
  int v2; // r7
  int *v3; // r5
  char *v4; // r2
  int v5; // t1
  int v6; // r4
  int v7; // t1

  v1 = a1;
  v2 = (int)(a1 + 19);
  printf("\n NNA_NET_LAYER ----");
  v3 = v1 + 11;
  v4 = map_layer_type_name[*v1];
  printf("\n type \t  :%d [%s]");
  printf("\n out_data   :[%2d %2d]", v1[1], v1[2]);
  printf("\n in_data\t  :[%2d %2d %2d %2d]", v1[3], v1[4], v1[5], v1[6]);
  printf("\n hyper_data :[%2d %2d %2d %2d]", v1[7], v1[8], v1[9], v1[10]);
  printf("\n data_pram  :[");
  do
  {
    v5 = *v3;
    ++v3;
    printf("%d ", v5);
  }
  while ( v3 != (int *)v2 );
  v6 = (int)(v1 + 35);
  putchar(93);
  printf("\n op_pram\t  :[");
  do
  {
    v7 = *v3;
    ++v3;
    printf("%d ", v7);
  }
  while ( (int *)v6 != v3 );
  return putchar(93);
}
// 19E4: using guessed type char *map_layer_type_name[9];

//----- (0000029C) --------------------------------------------------------
int __fastcall nna_net_dump_info(int a1)
{
  int v1; // r4
  int v2; // r6
  _DWORD *v3; // r5
  int v4; // r3
  int v5; // r11
  int v6; // r10
  _DWORD *v7; // r8
  int v8; // r9
  _DWORD *v9; // ST00_4

  v1 = a1;
  v2 = 0;
  printf("\n NNA_NET----");
  printf("\n name \t  :%s", v1);
  printf("\n layers_num :%d", *(_DWORD *)(v1 + 20));
  printf("\n io_base\t  :%x", *(_DWORD *)(v1 + 24));
  printf("\n hyper_base :%x", *(_DWORD *)(v1 + 28));
  printf("\n net_count  :%d", *(_DWORD *)(v1 + 48));
  nna_net_dump_quant(*(_DWORD **)(v1 + 44));
  nna_net_dump_quant((_DWORD *)(*(_DWORD *)(v1 + 44) + 900));
  nna_net_dump_quant((_DWORD *)(*(_DWORD *)(v1 + 44) + 1800));
  nna_net_dump_quant((_DWORD *)(*(_DWORD *)(v1 + 44) + 2700));
  while ( v2 < *(_DWORD *)(v1 + 20) )
  {
    printf("\n NNA_NET_LAYER ----[%d]", v2);
    v3 = (_DWORD *)(*(_DWORD *)(v1 + 40) + 140 * v2++);
    nna_net_dump_layer(v3);
    v4 = *(_DWORD *)(v1 + 36);
    v5 = v3[1];
    v6 = *(_DWORD *)(v1 + 32);
    v7 = (_DWORD *)(v4 + 284 * v3[7]);
    v8 = v3[3];
    v9 = (_DWORD *)(v4 + 284 * v3[8]);
    printf("\n OUT DATA    ---- [%d]", v3[1]);
    nna_net_dump_data((_DWORD *)(v6 + 284 * v5));
    printf("\n IN  DATA    ---- [%d]", v3[3]);
    nna_net_dump_data((_DWORD *)(v6 + 284 * v8));
    printf("\n HYPER   ---- [%d]", v3[7]);
    nna_net_dump_data(v7);
    printf("\n HYPER   ---- [%d]", v3[8]);
    nna_net_dump_data(v9);
  }
  return putchar(10);
}

//----- (0000045C) --------------------------------------------------------
int __fastcall nna_save_ram(int a1, int a2, const char *a3)
{
  int v3; // r4
  int v4; // r7
  const char *v5; // r6
  FILE *v6; // r0
  int v7; // r1
  FILE *v8; // r5

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = fopen(a3, "wb");
  v8 = v6;
  if ( v6 )
  {
    xfile(v6, v7, v4);
    fclose(v8);
  }
  else
  {
    v3 = 0;
    printf("#!!!nna_save_ram open file fail :%s ", v5);
  }
  return v3;
}
// 1FD0: using guessed type int __cdecl xfile(_DWORD, _DWORD, _DWORD);

//----- (000004DC) --------------------------------------------------------
int __fastcall nna_load_ram(int a1, const char *a2, int a3)
{
  const char *v3; // r6
  int v4; // r7
  FILE *v5; // r0
  FILE *v6; // r5
  int v7; // r4
  int v9; // r1
  int v10; // [sp+8h] [bp-18h]

  v10 = a3;
  v3 = a2;
  v4 = a1;
  v5 = fopen(a2, "rb");
  v6 = v5;
  if ( v5 )
  {
    fseek(v5, 0, 2);
    v7 = ftell(v6);
    fseek(v6, 0, 0);
    if ( !v7 )
      printf("\n# !!! nna_load_ram file :%s size:%d ", v3, 0);
    xfile(v6, v9, v4);
    printf("\n# %08x[%8d]<-- %s ", v4, v7, v3, v7, 114, v10);
    fclose(v6);
  }
  else
  {
    v7 = 0;
    printf("\n#!!!nna_load_ram open file fail :%s ", v3);
  }
  return v7;
}
// 1FD0: using guessed type int __cdecl xfile(_DWORD, _DWORD, _DWORD);

//----- (000005C0) --------------------------------------------------------
int __fastcall nna_load_buf(void *a1, int a2, char *a3)
{
  int v3; // r5
  void *v4; // r6
  char *v5; // r4
  FILE *v6; // r3
  int result; // r0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = fopen(a3, "rb");
  if ( !v6 )
    return printf("\n#!!!nna_load_buf open file fail :%s ", v5);
  result = fread(v4, 1u, v3, v6);
  if ( v3 > result )
    result = printf("\n!!! nna_load_buf read file :%s  error :%d [%d]", v5, result, v3);
  return result;
}

//----- (00000648) --------------------------------------------------------
int __fastcall nna_save_buf(void *a1, int a2, char *a3)
{
  int v3; // r5
  void *v4; // r6
  char *v5; // r4
  FILE *v6; // r3
  int result; // r0

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = fopen(a3, "wb");
  if ( !v6 )
    return printf("\n#!!!nna_save_buf open file fail :%s ", v5);
  result = fwrite(v4, 1u, v3, v6);
  if ( v3 > result )
    result = printf("\n!!! nna_save_buf read file: %s error :%d [%d]", v5, result, v3);
  return result;
}

//----- (000006D0) --------------------------------------------------------
int __fastcall nna_net_get_quant(int a1, int a2, int a3)
{
  return *(char *)(*(_DWORD *)(a1 + 44) + 900 * a2 + *(_DWORD *)(*(_DWORD *)(a1 + 44) + 900 * a2 + 4 * a3 + 4) + 516);
}

//----- (00000700) --------------------------------------------------------
int __fastcall nna_net_load_quant(_DWORD *a1)
{
  _DWORD *v1; // r5
  int v2; // r4
  int v3; // r0
  int result; // r0
  int i; // r4
  int v6; // r7
  int v7; // r0
  int v8; // r2
  _DWORD *v9; // r3
  int v10; // r1

  v1 = a1;
  v2 = 0;
  do
  {
    v3 = v1[11] + v2;
    v2 += 900;
    result = nna_load_buf((void *)(v3 + 516), *(_DWORD *)v3, (char *)(v3 + 644));
  }
  while ( v2 != 3600 );
  for ( i = 0; i < v1[5]; ++i )
  {
    v6 = -nna_net_get_quant((int)v1, 1, i);
    v7 = nna_net_get_quant((int)v1, 3, i);
    v8 = v1[10];
    result = v7 << 8;
    v9 = (_DWORD *)(v8 + 140 * i);
    v10 = *(_DWORD *)(v8 + 140 * i);
    v9[11] = v6;
    v9[12] = result;
    if ( v10 == 5 )
    {
      result = v8 + 140 * v9[3];
      v9[12] = *(_DWORD *)(result + 44) - *(_DWORD *)(v8 + 140 * v9[4] + 44);
    }
  }
  return result;
}

//----- (000007C4) --------------------------------------------------------
int __fastcall nna_net_load_data(int result)
{
  int v1; // r6
  _DWORD *v2; // r5
  __int64 v3; // r8
  int v4; // r3
  _DWORD *v5; // r2
  int v6; // r3
  _DWORD *v7; // r1
  int v8; // r1
  int v9; // r0
  int v10; // r3
  int v11; // r4
  int v12; // r3
  int v13; // r10
  int v14; // r3
  int v15; // r7
  int v16; // r1
  int v17; // r11
  int v18; // r2
  int v19; // r2
  int v20; // [sp+8h] [bp-48h]
  int v21; // [sp+Ch] [bp-44h]
  int v22; // [sp+10h] [bp-40h]

  v1 = *(_DWORD *)(result + 16);
  if ( !v1 )
  {
    v2 = (_DWORD *)result;
    v3 = *(unsigned int *)(result + 24);
    while ( v1 < v2[5] )
    {
      v20 = 140 * v1;
      v4 = v2[10];
      v21 = v4;
      v5 = (_DWORD *)(v4 + 140 * v1);
      v6 = *(_DWORD *)(v4 + 140 * v1);
      if ( v6 )
      {
        if ( (unsigned int)(v6 - 1) > 2 )
        {
          if ( v6 == 5 )
          {
            v11 = v2[8];
            v12 = 284 * v5[1];
            v22 = v12;
            v13 = v11 + v12;
            v14 = 284 * v5[3];
            v15 = 284 * v5[4];
            v16 = v11 + v14;
            v17 = v11 + v15;
            if ( !*(_DWORD *)(v11 + v14) )
            {
              v18 = *(_DWORD *)(v16 + 8);
              *(_DWORD *)(v11 + v14) = v3;
              v3 += v18;
            }
            if ( !*(_DWORD *)(v11 + v15) )
            {
              v19 = *(_DWORD *)(v17 + 8);
              *(_DWORD *)(v11 + v15) = v3;
              v3 += v19;
            }
            if ( !*(_DWORD *)(v11 + v22) )
            {
              *(_DWORD *)(v11 + v22) = v3;
              v3 += *(signed int *)(v13 + 8);
            }
            printf(
              "\n# load layer:%d %s in  :%x sz :%5d file: %s",
              v1,
              off_19F8[0],
              *(_DWORD *)(v11 + v14),
              *(_DWORD *)(v16 + 8),
              v16 + 28);
            printf(
              "\n# load layer:%d %s in2 :%x sz :%5d file: %s",
              v1,
              map_layer_type_name[*(_DWORD *)(v21 + v20)],
              *(_DWORD *)(v11 + v15),
              *(_DWORD *)(v17 + 8),
              v17 + 28);
            result = printf(
                       "\n# load layer:%d %s out :%x sz :%5d file: %s",
                       v1,
                       map_layer_type_name[*(_DWORD *)(v21 + v20)],
                       *(_DWORD *)(v11 + v22),
                       *(_DWORD *)(v13 + 8),
                       v13 + 28);
          }
        }
        else
        {
          v8 = v2[8];
          v9 = 284 * v5[1];
          v10 = 284 * v5[3];
          if ( !*(_DWORD *)(v8 + v9) )
          {
            *(_DWORD *)(v8 + v9) = v3;
            v3 += *(signed int *)(v8 + v9 + 8);
          }
          result = *(_DWORD *)(v8 + v10);
          if ( !result )
          {
            *(_DWORD *)(v8 + v10) = v3;
            v3 += *(signed int *)(v8 + v10 + 8);
          }
        }
      }
      else
      {
        v7 = (_DWORD *)(v2[8] + 284 * v5[1]);
        *v7 = v3;
        v3 += 0x100000LL;
        v7[2] = v7[5] * v7[4] * v7[3];
      }
      ++v1;
    }
  }
  return result;
}
// 19E4: using guessed type char *map_layer_type_name[9];
// 19F8: using guessed type char *off_19F8[4];

//----- (00000A5C) --------------------------------------------------------
int __fastcall nna_net_load_hyper(int result)
{
  int v1; // r5
  _DWORD *v2; // r4
  int v3; // r8
  int v4; // r7
  int v5; // r2
  int v6; // r6
  int v7; // r1
  int v8; // r11
  int v9; // r10
  int v10; // ST14_4
  int v11; // r9
  int v12; // r0
  unsigned __int64 v13; // ST08_8
  int v14; // r0
  __int64 v15; // r2
  unsigned __int64 v16; // [sp+8h] [bp-48h]

  v1 = *(_DWORD *)(result + 16);
  if ( !v1 )
  {
    v2 = (_DWORD *)result;
    v16 = vshrd_n_u64(vdup_n_s32(*(_DWORD *)(result + 28)).n64_u64[0], 0x20u);
    while ( v1 < v2[5] )
    {
      v3 = v2[10];
      v4 = 140 * v1;
      v5 = v3 + 140 * v1;
      if ( (unsigned int)(*(_DWORD *)(v3 + 140 * v1) - 1) <= 2 )
      {
        v6 = v2[9];
        v7 = 284 * *(_DWORD *)(v5 + 28);
        v8 = 284 * *(_DWORD *)(v5 + 32);
        v9 = v6 + v7;
        *(_DWORD *)(v6 + v7) = v16;
        v10 = v7;
        v11 = v6 + v8;
        v12 = nna_load_ram(v16, (const char *)(v6 + v7 + 28), v16);
        *(_DWORD *)(v9 + 8) = v12;
        v13 = v16 + v12;
        *(_DWORD *)(v6 + v8) = v13;
        v14 = nna_load_ram(v13, (const char *)(v6 + v8 + 28), v13);
        HIDWORD(v15) = HIDWORD(v13);
        *(_DWORD *)(v11 + 8) = v14;
        LODWORD(v15) = v13 + v14;
        v16 = v15 + v14;
        printf(
          "\n# load layer:%2d %s wt :%x sz :%5d file: %s",
          v1,
          map_layer_type_name[*(_DWORD *)(v3 + v4)],
          *(_DWORD *)(v6 + v10),
          *(_DWORD *)(v9 + 8),
          v9 + 28);
        result = printf(
                   "\n# load layer:%2d %s bs :%x sz :%5d file: %s",
                   v1,
                   map_layer_type_name[*(_DWORD *)(v3 + v4)],
                   *(_DWORD *)(v6 + v8),
                   *(_DWORD *)(v11 + 8),
                   v11 + 28);
      }
      ++v1;
    }
    v2[4] = 0;
  }
  return result;
}
// 19E4: using guessed type char *map_layer_type_name[9];

//----- (00000BE8) --------------------------------------------------------
_DWORD *__fastcall nna_net_init_whc(_DWORD *result, int a2, int a3, int a4)
{
  signed int v4; // r7
  int v5; // r12
  signed int v6; // lr
  _DWORD *v7; // r10
  int v8; // r11
  int v9; // r9
  int v10; // r8
  int v11; // r3
  _DWORD *v12; // r4
  _DWORD *v13; // r5
  int *v14; // r6
  int v15; // r3
  int v16; // r3
  int v17; // r7
  int v18; // ST14_4
  int v19; // [sp+8h] [bp-38h]
  int v20; // [sp+Ch] [bp-34h]
  int v21; // [sp+10h] [bp-30h]

  v7 = result;
  v8 = 0;
  v19 = a2;
  v20 = a3;
  v21 = a4;
  while ( v8 < v7[5] )
  {
    v9 = v7[10];
    v10 = 140 * v8;
    v11 = v7[8];
    v12 = (_DWORD *)(v9 + 140 * v8);
    v13 = (_DWORD *)(v11 + 284 * *(_DWORD *)(v9 + 140 * v8 + 4));
    v14 = (int *)(v11 + 284 * *(_DWORD *)(v9 + 140 * v8 + 12));
    v15 = *(_DWORD *)(v9 + 140 * v8);
    if ( v15 )
    {
      if ( v15 == 1 )
      {
        v17 = nna_conv_get_output_w(v14[3], v12[20], v12[21], v12[22], v12[23]);
        v18 = nna_conv_get_output_h(v14[4], v12[20], v12[21], v12[22], v12[23]);
        v4 = nna_pool_get_output_w(v17, v12[28], v12[29], v12[30]);
        result = (_DWORD *)nna_pool_get_output_h(v18, v12[28], v12[29], v12[30]);
        v5 = v12[19];
        v6 = (signed int)result;
      }
    }
    else
    {
      v13[3] = v19;
      v13[4] = v20;
      v13[5] = v21;
      v14[3] = v19;
      v4 = v13[3];
      v14[4] = v20;
      v6 = v13[4];
      v14[5] = v21;
      v5 = v13[5];
    }
    if ( *(_DWORD *)(v9 + v10) == 2 )
    {
      v4 = nna_conv_get_output_w(v14[3], v12[20], v12[21], v12[22], v12[23]);
      result = (_DWORD *)nna_conv_get_output_h(v14[4], v12[20], v12[21], v12[22], v12[23]);
      v5 = v12[19];
      v6 = (signed int)result;
    }
    ++v8;
    if ( *(_DWORD *)(v9 + v10) == 3 )
    {
      v6 = 1;
      v5 = v12[19];
      v4 = 1;
    }
    v13[3] = v4;
    v16 = v5 + 7;
    v13[4] = v6;
    if ( v5 + 7 < 0 )
      v16 = v5 + 14;
    v13[5] = v5;
    v13[2] = v6 * v4 * (v16 & 0xFFFFFFF8);
  }
  return result;
}

//----- (00000D8C) --------------------------------------------------------
int __fastcall nna_net_init(int result, int a2, signed int a3, int a4)
{
  signed int v4; // r7
  _DWORD *v5; // r10
  int v6; // r11
  int v7; // r9
  int v8; // r8
  int v9; // r1
  _DWORD *v10; // r4
  _DWORD *v11; // r6
  int *v12; // r5
  int v13; // r1
  int v14; // r1
  int v15; // r2
  int v16; // r3
  signed int v17; // r0
  int v18; // r1
  int v19; // r7
  int v20; // ST0C_4
  signed int v21; // r0
  int v22; // r1

  v5 = (_DWORD *)result;
  v6 = 0;
  while ( v6 < v5[5] )
  {
    v7 = v5[10];
    v8 = 140 * v6;
    v9 = v5[8];
    v10 = (_DWORD *)(v7 + 140 * v6);
    v11 = (_DWORD *)(v9 + 284 * *(_DWORD *)(v7 + 140 * v6 + 4));
    v12 = (int *)(v9 + 284 * *(_DWORD *)(v7 + 140 * v6 + 12));
    v13 = *(_DWORD *)(v7 + 140 * v6);
    if ( v13 )
    {
      if ( v13 == 1 )
      {
        v19 = nna_conv_get_output_w(v12[3], v10[20], v10[21], v10[22], v10[23]);
        v20 = nna_conv_get_output_h(v12[4], v10[20], v10[21], v10[22], v10[23]);
        v4 = nna_pool_get_output_w(v19, v10[28], v10[29], v10[30]);
        v21 = nna_pool_get_output_h(v20, v10[28], v10[29], v10[30]);
        a4 = v10[19];
        a3 = v21;
      }
    }
    else
    {
      v14 = v10[19];
      v15 = v10[20];
      v16 = v10[21];
      v11[3] = v14;
      v11[4] = v15;
      v11[5] = v16;
      v12[3] = v14;
      v12[4] = v15;
      v12[5] = v16;
      v4 = v11[3];
      a3 = v11[4];
      a4 = v11[5];
    }
    if ( *(_DWORD *)(v7 + v8) == 2 )
    {
      v4 = nna_conv_get_output_w(v12[3], v10[20], v10[21], v10[22], v10[23]);
      v17 = nna_conv_get_output_h(v12[4], v10[20], v10[21], v10[22], v10[23]);
      a4 = v10[19];
      a3 = v17;
    }
    v18 = *(_DWORD *)(v7 + v8);
    switch ( v18 )
    {
      case 3:
        a3 = 1;
        a4 = v10[19];
        v4 = 1;
        break;
      case 5:
LABEL_10:
        v4 = v12[3];
        a3 = v12[4];
        a4 = v12[5];
        break;
      case 7:
        v4 = v12[3];
        a3 = v12[4];
        a4 = v10[19];
        break;
      case 6:
        goto LABEL_10;
    }
    v11[3] = v4;
    v22 = a4 + 7;
    v11[4] = a3;
    if ( a4 + 7 < 0 )
      v22 = a4 + 14;
    result = a3 * v4;
    ++v6;
    v11[5] = a4;
    v11[2] = a3 * v4 * (v22 & 0xFFFFFFF8);
  }
  return result;
}

//----- (00000F50) --------------------------------------------------------
int __fastcall nna_net_dump(_DWORD *a1)
{
  _DWORD *v1; // r6
  int v2; // r4
  int *v3; // r8
  int v4; // r1
  char s; // [sp+10h] [bp-128h]

  v1 = a1;
  v2 = 0;
  while ( v2 < v1[5] )
  {
    v3 = (int *)(v1[8] + 284 * *(_DWORD *)(v1[10] + 140 * v2 + 4));
    sprintf(&s, "net_%s_%d_layer_%02d_output_dump.bin", v1, v1[12], v2);
    nna_save_ram(*v3, v3[2], &s);
    v4 = v2++;
    printf("\n# layer  :%d", v4);
    nna_diff_file(v3 + 7, &s);
  }
  return putchar(10);
}
// 1FFC: using guessed type int __fastcall nna_diff_file(_DWORD, _DWORD);

//----- (00001010) --------------------------------------------------------
int __fastcall nna_net_forward(int result)
{
  int v1; // r0
  _DWORD *v2; // r4
  int v3; // r5
  int v4; // r9
  int v5; // r7
  int v6; // r8
  int *v7; // r6
  int v8; // r10
  int v9; // r3
  int v10; // r3
  int v11; // r3
  int v12; // r3
  int v13; // r3
  int v14; // r3
  int v15; // r3
  int v16; // [sp+50h] [bp-70h]
  int v17; // [sp+54h] [bp-6Ch]
  int v18; // [sp+58h] [bp-68h]
  int v19; // [sp+5Ch] [bp-64h]
  int v20; // [sp+60h] [bp-60h]
  _DWORD *v21; // [sp+64h] [bp-5Ch]
  char s; // [sp+78h] [bp-48h]

  v16 = 0;
  v21 = (_DWORD *)result;
  while ( v16 < v21[5] )
  {
    v1 = sprintf(&s, "layer_%d");
    v18 = 140 * v16;
    v2 = (_DWORD *)(v21[10] + 140 * v16);
    v19 = v21[10];
    v3 = v21[8];
    v4 = 284 * v2[3];
    v20 = 284 * v2[4];
    v5 = 284 * v2[1];
    v6 = v21[9];
    v7 = (int *)(v3 + v4);
    v17 = 284 * v2[7];
    v8 = 284 * v2[8];
    result = nna_reset(v1);
    if ( *(_DWORD *)(v19 + 140 * v16) == 1 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19E8[0]);
      printf("%x %x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v6 + v17), *(_DWORD *)(v6 + v8));
      printf("%2d %2d   %x %x  ", v2[11], v2[12], v2[13], v2[14]);
      printf("%3d %3d %3d  ", v7[3], v7[4], v7[5]);
      printf("%2d %d %d %d %d  ", v2[19], v2[20], v2[21], v2[22], v2[23]);
      printf("%d %d %x   ", v2[24], v2[25], v2[26]);
      printf("%d %d %d %d ", v2[27], v2[28], v2[29], v2[30]);
      v9 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_conv_act_pool(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v6 + v17),
                 *(_DWORD *)(v6 + v8),
                 v2[11],
                 v2[12],
                 v2[13],
                 v2[14],
                 v7[3],
                 v7[4],
                 v7[5],
                 v2[19],
                 v2[20],
                 v2[21],
                 v2[22],
                 v2[23],
                 v2[24],
                 v2[25],
                 v2[26],
                 v2[27],
                 v2[28],
                 v2[29],
                 v2[30]);
    }
    if ( *(_DWORD *)(v19 + v18) == 2 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19EC[0]);
      printf("%x %x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v6 + v17), *(_DWORD *)(v6 + v8));
      printf("%2d %2d   %x %x  ", v2[11], v2[12], v2[13], v2[14]);
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%2d %d %d %d %d   ", v2[19], v2[20], v2[21], v2[22], v2[23]);
      printf("%d %d %x   ", v2[24], v2[25], v2[26]);
      v10 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_api_conv_act(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v6 + v17),
                 *(_DWORD *)(v6 + v8),
                 v2[11],
                 v2[12],
                 v2[13],
                 v2[14],
                 v7[3],
                 v7[4],
                 v7[5],
                 v2[19],
                 v2[20],
                 v2[21],
                 v2[22],
                 v2[23],
                 v2[24],
                 v2[25],
                 v2[26]);
    }
    if ( *(_DWORD *)(v19 + v18) == 3 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19F0[0]);
      printf("%x %x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v6 + v17), *(_DWORD *)(v6 + v8));
      printf("%2d %2d  ", v2[11], v2[12]);
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%d %d ", v2[19], v2[20]);
      v11 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_api_inner_product(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v6 + v17),
                 *(_DWORD *)(v6 + v8),
                 v2[11],
                 v2[12],
                 v7[3],
                 v7[4],
                 v7[5],
                 v2[19],
                 v2[20]);
    }
    if ( *(_DWORD *)(v19 + v18) == 4 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19F4[0]);
      printf(
        "%x %x %x %x %x  ",
        *(_DWORD *)(v3 + v5),
        *(_DWORD *)(v3 + v4),
        *(_DWORD *)(v3 + v20),
        *(_DWORD *)(v6 + v17),
        *(_DWORD *)(v6 + v8));
      printf("%2d %2d   %x %x  ", v2[11], v2[12], v2[13], v2[14]);
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%2d %d %d %d %d   ", v2[19], v2[20], v2[21], v2[22], v2[23]);
      printf("%d %d %x   ", v2[24], v2[25], v2[26]);
      printf("%d %d %d   ", v2[27], v2[28], v2[29]);
      v12 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_api_conv_act_eltwise(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v3 + v20),
                 *(_DWORD *)(v6 + v17),
                 *(_DWORD *)(v6 + v8),
                 v2[11],
                 v2[12],
                 v2[13],
                 v2[14],
                 v7[3],
                 v7[4],
                 v7[5],
                 v2[19],
                 v2[20],
                 v2[21],
                 v2[22],
                 v2[23],
                 v2[24],
                 v2[25],
                 v2[26],
                 v2[27],
                 v2[28],
                 v2[29]);
    }
    if ( *(_DWORD *)(v19 + v18) == 5 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19F8[0]);
      printf("%x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v3 + v20));
      printf("%2d %2d  ", v2[11], v2[12]);
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%d %d ", v2[19], v2[20]);
      v13 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_eltwise_cpu(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v3 + v20),
                 v2[11],
                 v7[3],
                 v7[4],
                 v7[5],
                 v2[19],
                 v2[20],
                 v2[21]);
    }
    if ( *(_DWORD *)(v19 + v18) == 6 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_19FC[0]);
      printf("%x %x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v6 + v17), *(_DWORD *)(v6 + v8));
      printf("%2d %2d  ", v2[11], v2[12]);
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%d %d ", v2[19], v2[20]);
      v14 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_sigmoid_cpu(*(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), v2[11], v2[12], v7[3], v7[4], v7[5], v2[19]);
    }
    if ( *(_DWORD *)(v19 + v18) == 7 )
    {
      printf("\n# forward layer:%02d %s T:%d\t", v16, off_1A00[0]);
      printf("%x %x %x  ", *(_DWORD *)(v3 + v5), *(_DWORD *)(v3 + v4), *(_DWORD *)(v3 + v20));
      printf("%2d %2d %2d  ", v7[3], v7[4], v7[5]);
      printf("%d  ", v2[19]);
      v15 = *(_DWORD *)(v3 + v5 + 8);
      xramset(*(_DWORD *)(v3 + v5), 0);
      result = nna_concat_cpu(
                 *(_DWORD *)(v3 + v5),
                 *(_DWORD *)(v3 + v4),
                 *(_DWORD *)(v3 + v20),
                 v7[3],
                 v7[4],
                 v7[5],
                 *(_DWORD *)(v3 + v20 + 20));
    }
    ++v16;
  }
  ++v21[12];
  return result;
}
// 19E8: using guessed type char *off_19E8[8];
// 19EC: using guessed type char *off_19EC[7];
// 19F0: using guessed type char *off_19F0[6];
// 19F4: using guessed type char *off_19F4[5];
// 19F8: using guessed type char *off_19F8[4];
// 19FC: using guessed type char *off_19FC[3];
// 1A00: using guessed type char *off_1A00[2];
// 2000: using guessed type int __fastcall nna_reset(_DWORD);
// 2004: using guessed type int __fastcall xramset(_DWORD, _DWORD);
// 2008: using guessed type int __fastcall nna_conv_act_pool(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2018: using guessed type int __fastcall nna_eltwise_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 201C: using guessed type int __fastcall nna_sigmoid_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 2020: using guessed type int __fastcall nna_concat_cpu(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

// ALL OK, 16 function(s) have been successfully decompiled
